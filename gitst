#!/bin/sh

# Helper script to check if a git working copy needs any attention.

set -e

git fetch --prune --quiet --all > /dev/null

r=$(git status --porcelain 2>&1)
if [ -n "$r" ]; then
    printf ' *** git working copy has uncommited changes:\n%s\n\n' "$r"
fi

r=$(git stash list 2>&1)
if [ -n "$r" ]; then
    printf ' *** git working copy has stashed changes:\n%s\n\n' "$r"
fi

# RH: FIX: This can give "fatal: ref refs/remotes/origin/HEAD is not a symbolic ref".
# See <https://stackoverflow.com/questions/17639383/how-to-add-missing-origin-head-in-git-repo/17639471#17639471>.
# TL;DR: origin/HEAD only exists on cloned repos, and the remote might not even be called "origin"
# To fix: check the existence of local branches "main" or "master", in that order, and use those.
# If neither exists, assume "main".
default_branch=$(git symbolic-ref --short refs/remotes/origin/HEAD)
default_branch=$(printf '%s' "$default_branch" | sed 's/^origin\///')
current_branch=$(git symbolic-ref --short HEAD)

if [ "$current_branch" != "$default_branch" ]; then
    printf ' *** current git branch is "%s", but the default branch is "%s"\n\n' "$current_branch" "$default_branch"
fi

r=$(git status --porcelain --branch | egrep '^## [a-zA-Z0-9./_-]+') # get only branch info
if printf '%s' "$r" | egrep --invert-match --quiet '^## [a-zA-Z0-9./_-]+\.\.\.[a-zA-Z0-9./_-]+'; then
    printf ' *** current git branch "%s" does not have a remote tracking branch\n\n' "$current_branch"
elif printf '%s' "$r" | egrep --quiet '^## [a-zA-Z0-9./_-]+ \[(ahead|behind|gone)'; then
    printf ' *** current git branch is not in sync with remote:\n%s\n\n' "$r"
fi
